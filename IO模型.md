# IO模型
## 一、基本概念
介绍I/O模型之前，先了解一下几个概念：

### 同步与异步
同步和异步关注的是消息通信机制(谓同步,就是在发出一个调用时,在没有得到结果之前,该调用就不返回。但是一旦调用主动等待这个调用的结果；而异步则是相反,调用在发出之后,这个调用就直接返回了,所以没有返回结果。换句话说,当调用者不会立刻得到结果。而是在调用发出后,被调用者通过状知来通知调用者,或通过回调函数处理这个调用

### 阻塞与非阻塞
阻塞和非阻塞关注的是程序在等待调用结果(消息，返回值)时的状态。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

### 阻塞、非阻塞和同步、异步的区别
阻塞、非阻塞和同步、异步其实针对的对象是不一样的，阻塞、非阻塞的讨论对象是调用者；同步、异步的讨论对象是被调用者。

同步非同步及阻塞非阻塞的划分如下：
![](https://i.imgur.com/iTZgGVz.png)

## 二、IO与NIO
IO 最早指的是文件的Input/Output，之后IO也包括网络IO。
网络IO只要一个线程过来就需要创建一个线程，这样会导致资源不够用，很浪费资源。

### 1、一般IO存在的问题
* 线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起
* 线程切换效率低下：单机CPU核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。
* 除了以上两个问题，IO编程中，我们看到数据读写是以字节流为单位

### 2、NIO
NIO模型中，他把这么多while死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个while死循环就能监测1w个连接是否有数据可读的。这就是NIO模型中selector的作用，一条连接来了之后，现在不创建一个while死循环去监听是否有数据可读了，而是直接把这条连接注册到selector上，然后通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据。

### 3、IO 和 NIO 的区别
![](https://i.imgur.com/IKWo609.png)

#### （1）读写方式
IO读写是面向流的，一次性只能从流中读取一个或者多个字节，并且读完之后流无法再读取，你需要自己缓存数据。Java NIO的读写是面向Buffer的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是还需要检查是否该缓冲区中包含所有您需要处理的数据。而且需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

#### （2）阻塞与非阻塞IO
Java IO的各种流是阻塞的。这意味着，当一个线程调用read()或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

#### （3）选择器（Selectors）
Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

## 三、IO模型的分类
一个输入操作通常包括两个不同的阶段：
* 等待数据准备好
* 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核总的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为5种I/O模型：
* 同步模型（synchronous IO） 
* 阻塞IO（bloking IO） 
* 非阻塞IO（non-blocking IO） 
* 多路复用IO（multiplexing IO） 
* 信号驱动式IO（signal-driven IO）
* 异步IO（asynchronous IO）

### 1、同步阻塞
同步阻塞IO模式下Socket创建一个新的 Thread,线程模型如下图所示：
![](https://i.imgur.com/rprHX4l.png)
该种模型存在以下两个问题： 
1. 在任何时候都可能有大量的线程处于休眠状态，只是等待输入或者输出数据就绪，这可能算是一种资源浪费 
2. 需要为每个线程的调用栈都分配内存；即使 Java 虚拟机（JVM） 在物理上可以支持非常大数量的线程， 但是远在到达该极限之前， 上下文切换所带来的开销就会带来麻烦

特点：在IO执行的两个阶段都被Block
优点：能够及时返回数据无延迟，方便开发
缺点：性能比较低
![](https://i.imgur.com/Lxovjbt.png)
 在上图中，进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发送错误才返回。最常见的错误是系统调用被信号中断，我们说进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。

### 2、同步非阻塞
特点：就是用户进程需要不断的主动询问数据是否准备好
优点：能够在等待任务完成的时间里干其它的，也就是后台可以有多个任务同时执行
缺点：任务完成的响应延迟增大，整体的数据吞吐量降低
![](https://i.imgur.com/pJUbFGf.png)
前三次调用recvfrom时没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。接着处理数据。当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们成为轮询，应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间。


### 3、IO多路复用（同步阻塞）
#### （1）定义
多路复用IO(IO multiplexing)是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。在Linux系统中，常用的多路复用IO 手段有select、poll和epoll 。
#### （2）使用
多路复用IO主要用于处理网络请求，例如可以把多个请求句柄添加到  select中进行监听，当有请求可进行IO的时候就会告知进程，并且把就绪的请求句柄保存下来，进程只需要对这些就绪的请求进行IO操作即可。下面通过一幅图来展示select 的使用方式：
![](https://i.imgur.com/BFLqHr1.jpg)

#### （3）特点
通过一种机制一个进程同时等待多个IO文件描述符，内核监视这些文件描述符，其中任意一个进入就绪状态，select、poll、epoll函数就可以返回。监视方式分为：select、poll、epoll。并且，能够同时处理多个处于监听状态或多个连接状态的套接字，同时处理多种协议的套接字
![](https://i.imgur.com/JLMUU2X.png)


上面三种都为同步IO。
（同步主动等待消息通知，异步被动接收消息通知）
同步模型从整个IO模型来看它们都是顺序执行的，都是进程主动等待且向内核检查状态。

### 4、信号驱动式IO
我们首先开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理。也可以立即通知循环，让它读取数据报。
无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。
![](https://i.imgur.com/KMNzu3Z.png)

### 5、异步非阻塞IO模型
告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与信号驱动模型的主要区别在于：信号驱动I/O是由内核通知我们如何启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。
![](https://i.imgur.com/mcGgErC.png)
我们调用aio_read函数，给内核传递描述符、缓冲区指针。缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等到I/O完成期间，我们的进程不被阻塞。

### 6、五种不同IO的对比
前四种模型的主要区别在于第一阶段，因为它们的第二阶段是一样的：在数据从内核复制到调用者的缓冲区期间，进程阻塞与recvfrom调用。相反，异步I/O模型在这两个阶段都要处理
![](https://i.imgur.com/E9R95Ul.png)

### 7、同步IO和异步IO
* 同步IO操作导致请求进程阻塞，直到IO操作完成
* 异步IO操作不导致请求进行阻塞

从理论上讲，非阻塞IO、阻塞IO、IO复用和信号驱动IO都是同步IO模型。因为这四种IO模型中，IO的读写操作，都是在IO事件发生之后，由应用进程来完成的。而POSIX规范所定义的异步IO模型则不同。对异步IO而言，用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后内核通知应用程序的方式。异步IO的读写操作总是立即返回，而不论IO是否是阻塞的，因为真正的读写操作已经由内核接管。也就是说，同步IO模型要求用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区），而异步IO机制则由内核来执行IO操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的）。你可以这样认为，同步IO向应用程序通知的是IO就绪事件，而异步IO向应用程序通知的是IO完成事件。

## 四、epoll的本质
### 1、从网卡接收数据说起
下边是一个典型的计算机结构图，计算机由CPU、存储器（内存）与网络接口等部件组成，了解epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。
下图展示了网卡接收数据的过程。
* 在①阶段，网卡收到网线传来的数据；
* 经过②阶段的硬件电路的传输；
* 最终③阶段将数据写入到内存中的某个地址上。

这个过程涉及到DMA传输、IO通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。
![](https://i.imgur.com/hpeUtiv.jpg)

通过硬件传输，网卡接收的数据存放到内存中，操作系统就可以去读取它们。

### 2、如何知道接收了数据？
了解epoll本质的第二步，要从CPU的角度来看数据接收。理解这个问题，要先了解一个概念——中断。

计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时，它应立即去保存数据，保存数据的程序具有较高的优先级（电容可以保存少许电量，供CPU运行很短的一小段时间）。

一般而言，由硬件产生的信号需要CPU立马做出回应，不然数据可能就丢失了，所以它的优先级很高。CPU理应中断掉正在执行的程序，去做出响应；当CPU完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，它和函数调用差不多，只不过函数调用是事先定好位置，而中断的位置由“信号”决定。
![](https://i.imgur.com/RolGAi7.jpg)

以键盘为例，当用户按下键盘某个按键时，键盘会给CPU的中断引脚发出一个高电平，CPU能够捕获这个信号，然后执行键盘中断程序。下图展示了各种硬件通过中断与CPU交互的过程。
![](https://i.imgur.com/QxwTOfb.jpg)

现在可以回答“如何知道接收了数据？”这个问题了：当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。

### 3、进程阻塞为什么不占用CPU资源？
了解 epoll 本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法。下边分析一下进程阻塞为什么不占用 CPU 资源？

为简单起见，我们从普通的 recv 接收开始分析，先看看下面代码：
```

//创建socket
int s = socket(AF_INET, SOCK_STREAM, 0);   
//绑定
bind(s, ...)
//监听
listen(s, ...)
//接受客户端连接
int c = accept(s, ...)
//接收客户端数据
recv(c, ...);
//将数据打印出来
printf(...)
```
这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen 与 accept，最后调用 recv 接收数据。recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。

**工作队列**

操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得 CPU 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。

下图的计算机中运行着 A、B 与 C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这 3 个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。
![](https://i.imgur.com/PbWtEQu.jpg)

**等待队列**

当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象（如下图）。这个 socket 对象包含了发送缓冲区、接收缓冲区与等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程。
![](https://i.imgur.com/IZpFlEu.jpg)

当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中（如下图）。由于工作队列只剩下了进程 B 和 C，依据进程调度，CPU 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 CPU 资源。
![](https://i.imgur.com/gb6dy7Y.jpg)

> 注：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。

**唤醒进程**
当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。同时由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。

### 4、内核接收网络数据全过程
这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞recv下，内核接收数据的全过程。

如下图所示，进程在recv阻塞期间，计算机收到了对端传送的数据（步骤①），数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知CPU有数据到达，CPU执行中断程序（步骤③）。

此处的中断程序主要有两项功能，先将网络数据写入到对应 socket 的接收缓冲区里面（步骤④），再唤醒进程 A（步骤⑤），重新将进程 A 放入工作队列中。
![](https://i.imgur.com/CU97c7N.jpg)

唤醒进程的过程如下图所示：
![](https://i.imgur.com/Tmp215W.jpg)

以上是内核接收数据全过程，这里我们可能会思考两个问题：
* 其一，操作系统如何知道网络数据对应于哪个socket？
* 其二，如何同时监视多个socket的数据？

第一个问题：因为一个socket对应着一个端口号，而网络数据包中包含了ip和端口的信息，内核可以通过端口号找到对应的 socket。当然，为了提高处理速度，操作系统会维护端口号到 socket的索引结构，以快速读取。

第二个问题是多路复用的重中之重，也正是本文后半部分的重点。

### 5、同时监视多个socket的简单方法
服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。epoll的要义就是高效地监视多个socket。

从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进，正如select之于epoll。

先理解不太高效的select，才能够更好地理解epoll的本质。

假如能够预先传入一个socket列表，如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程。这种方法很直接，也是select的设计思想。

为方便理解，我们先复习select的用法。在下边的代码中，先准备一个数组fds，让fds存放着所有需要监视的socket。然后调用 select，如果 fds 中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET 判断具体哪个socket收到数据，然后做出处理。

```
int s = socket(AF_INET, SOCK_STREAM, 0);  
bind(s, ...);
listen(s, ...);
int fds[] =  存放需要监听的socket;
while(1){
    int n = select(..., fds, ...)
    for(int i=0; i < fds.count; i++){
        if(FD_ISSET(fds[i], ...)){
            //fds[i]的数据处理
        }
    }}
```
**select 的流程**

select 的实现思路很直接，假如程序同时监视如下图的 sock1、sock2 和 sock3 三个 socket，那么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。
![](https://i.imgur.com/rSUMqkU.jpg)

当任何一个 socket 收到数据后，中断程序将唤起进程。下图展示了 sock2 接收到了数据的处理流程：

> 注：recv 和 select 的中断回调可以设置成不同的内容。

![](https://i.imgur.com/WwctPLb.jpg)

所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：
![](https://i.imgur.com/a4zkNTj.jpg)

经由这些步骤，当进程 A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket 列表，就可以得到就绪的 socket。

这种简单方式行之有效，在几乎所有操作系统都有对应的实现。
但是简单的方法往往有缺点，主要是：
* 其一，每次调用 select 都需要将进程加入到所有监视 socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 fds 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024 个 socket。
* 其二，进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。

那么，有没有减少遍历的方法？有没有保存就绪 socket 的方法？这两个问题便是 epoll 技术要解决的。

> 补充说明： 本节只解释了 select 的一种情形。当程序调用 select 时，内核会先遍历一遍 socket，如果有一个以上的 socket 接收缓冲区有数据，那么 select 直接返回，不会阻塞。这也是为什么 select 的返回值有可能大于 1 的原因之一。如果没有 socket 有数据，进程才会阻塞。

### 6、epoll 的设计思路
epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll（poll 和 select 基本一样，有少量改进）的增强版本。epoll 通过以下一些措施来改进效率：

**措施一：功能分离**
select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见地，效率就能得到提升。
![](https://i.imgur.com/F7dt6ct.jpg)

为方便理解后续的内容，我们先了解一下epoll的用法。如下的代码中，先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据：
```
int s = socket(AF_INET, SOCK_STREAM, 0);   
bind(s, ...)
listen(s, ...)

int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中

while(1){
    int n = epoll_wait(...)
    for(接收到数据的socket){
        //处理
    }
}
```
功能分离，使得epoll有了优化的可能。

**措施二：就绪列表**
select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被就绪列表rdlist所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。
![](https://i.imgur.com/UC4KoPR.jpg)


### 7、epoll 的原理与工作流程
本节会以示例和图表来讲解epoll的原理和工作流程。

**创建 epoll 对象**
如下图所示，当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中 epfd 所代表的对象）。eventpoll对象也是文件系统中的一员，和 ocket一样，它也会有等待队列。
![](https://i.imgur.com/L7EbTg1.jpg)

创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。

**维护监视列表**

创建epoll对象后，可以用epoll_ctl 添加或删除所要监听的 socket。以添加socket为例，如下图，如果通过epoll_ctl添加 sock1、sock2 和 sock3 的监视，内核会将eventpoll添加到这三个socket的等待队列中。
![](https://i.imgur.com/Ce6o1Kk.jpg)

当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。

**接收数据**
当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如下图展示的是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket。
![](https://i.imgur.com/8Tk8DHX.jpg)

eventpoll对象相当于socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。

当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。

**阻塞和唤醒进程**
假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了 epoll_wait语句。如下图所示，内核会将进程A放入eventpoll 的等待队列中，阻塞进程。
![](https://i.imgur.com/S22AhOX.jpg)

当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态（如下图）。也因为 rdlist 的存在，进程 A 可以知道哪些 socket 发生了变化。
![](https://i.imgur.com/XW9Ucxm.jpg)

### 8、epoll的实现细节
至此，相信读者对epoll的本质已经有一定的了解。但我们还需要知道 eventpoll 的数据结构是什么样子？
此外，就绪队列应该应使用什么数据结构？eventpoll应使用什么数据结构来管理通过epoll_ctl添加或删除的socket？
如下图所示，eventpoll包含了lock、mtx、wq（等待队列）与 rdlist等成员，其中rdlist和rbr是我们所关心的。
![](https://i.imgur.com/XqQd4cW.jpg)

**就绪列表的数据结构**
就绪列表引用着就绪的socket，所以它应能够快速的插入数据。
程序可能随时调用epoll_ctl添加监视socket，也可能随时删除。当删除时，若该socket已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。
双向链表就是这样一种数据结构，epoll使用双向链表来实现就绪队列（对应上图的rdllist）。

**索引结构**
既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好，epoll使用了红黑树作为索引结构（对应上图的 rbr）。

> 注：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist并非直接引用socket，而是通过epitem间接引用，红黑树的节点也是epitem对象。同样，文件系统也并非直接引用着socket。为方便理解，本文中省略了一些间接结构。

### 9、小结
epoll在select和poll的基础上引入了eventpoll作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。这里也以表格形式简单对比一下select、poll与epoll，结束此文。希望读者能有所收获。 
![](https://i.imgur.com/e6ygFq5.jpg)



